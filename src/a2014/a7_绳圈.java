package a2014;

import java.util.Arrays;

/*
 * 今有 100 根绳子，当然会有 200 个绳头。
    如果任意取绳头两两配对，把所有绳头都打结连接起来。
    最后会形成若干个绳圈（不考虑是否套在一起）。
    我们的问题是：请计算最后将形成多少个绳圈的概率最大？
    注意：结果是一个整数，请通过浏览器提交该数字。不要填写多余的内容。

本题对数学的推理要求比较高，首先我们要分析，现在有n根绳子，
那么任意选取其中两个绳头配对，直到所有绳头均已完成配对，有多少种情况呢？
假设n-1根绳子配对完毕共有f(n - 1)种情况，那么在此基础上加一根绳子，重新进行配对，
有以下两种情况可以选择：（1）绳圈个数不变，在n - 1根已配对完毕的绳头中选择一个绳头和当前新添加的一根绳子绳头打结连接起来；
（2）增加一个绳圈，直接让新添加的绳子两个绳头直接相连。
所以f(n) = f(n - 1) * (C(1, 2*(n - 1))+ C(0, 2*(n - 1))) = f(n - 1)  * (2*n - 2 + 1) = f(n - 1) * (2*n - 1)
有了上述公式，那么可以推导出解决本题的动态转移方程，
dp[i][j] = dp[i - 1][j] * (2*n - 2) / (2*n - 1) + dp[i - 1][j - 1] * (1) / (2*n - 1)
dp[i][j]表示当前有i根绳子，形成j个绳圈的概率。（PS：j > i，其概率为0）  
 */
public class a7_绳圈 {
	public static void main(String[] args) {
		double[][] n = new double[101][101];
		n[0][0]=0;
		n[1][1] = 1;
		for (int i = 2; i <=100; i++) {
			for (int j = 1; j <=i; j++) {
				n[i][j]=n[i-1][j]*2*(i-1)+n[i-1][j-1];					
			}
		}
		double max =0;
		int m=0;
		for (int i = 0; i < 101; i++) {
			if(n[100][i]>max) {
				max=n[100][i];
				m=i;
			}
		}
		for (int i = 0; i <20; i++) {
			System.out.println(Arrays.toString(n[i]));
		}
		System.out.println(m);
	}
}
