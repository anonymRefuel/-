package a2017;
/*
 * 4.标题：方格分割
6x6的方格，沿着格子的边线剪开成两部分。
要求这两部分的形状完全相同。
如图：p1.png, p2.png, p3.png 就是可行的分割法。
试计算：
包括这3种分法在内，一共有多少种不同的分割方法。
注意：旋转对称的属于同一种分割法。
请提交该整数，不要填写任何多余的内容或说明文字。

先贴个超时代码典范,按照往年真题剪邮票枚举+求联通快的做法，超时了，
2^18次方太多了，而且求出的答案也不一定正确，
基本的思路是对的，对称位置上的颜色不能一样，即vis[i][j]!=vis[5-i][5-j],
在此思路上，我们不妨从搜索块的思路上变成枚举分割线，从中心搜索到边界的线，
当然是从2个方向搜索的，不过其实只要搜索一个方向，另外个方向取对称点,对称分割
最后答案别忘了除4(对称),509
AC代码,对称分割，这题考察思维的转化，从关注点是格子转化为点,从而对称的搜索从答案 
 */

public class a4_方格分割 {
	static int ans;
	static int[][] vis;
	
	static int[][] a= {
			{-1,0},
			{1,0},
			{0,-1},
			{0,1}
	};
public static void main(String[] args) {
	vis = new int[7][7];
	dfs(3,3);
	System.out.println(ans/4);
}

static void dfs(int i,int j) {
	if(i<=0 || i>=6 || j<=0 || j>=6) {
		ans++;
		return;
	}
	//当前坐标标记为已访问
	vis[i][j] = 1;
	//对应坐标标记为已访问
	vis[6-i][6-j]=1;
	for (int m = 0; m < 4; m++) {
		//新坐标
		int ni = i+a[m][0];
		int nj = j+a[m][1];
		if(ni<0 || ni>6 || nj<0 || nj>6)continue;
		if(vis[ni][nj]==0)dfs(ni, nj);
	}
	//回溯
	vis[i][j] = 0;
	vis[6-i][6-j]=0;
}
}
